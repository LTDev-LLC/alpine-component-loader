{"version":3,"sources":["../src/debugger.js"],"names":["position","zIndex","background","color","padding","borderRadius","fontSize","fontFamily","pointerEvents","border","boxShadow","maxWidth","whiteSpace","display","top","left","width","height","overflow","boxSizing","toCssString","styleObj","Object","entries","map","k","v","replace","m","toLowerCase","join","ACLDebugger","inject","loaderClass","toggleDebug","active","globalConfig","debug","document","body","classList","toggle","tooltip","getElementById","createElement","id","style","cssText","titleNode","hr","margin","borderBottom","statusNode","propsNode","append","_nodes","title","status","props","appendChild","overlayContainer","mouseX","mouseY","hoveredElement","onMouseMove","e","clientX","clientY","composedPath","find","node","nodeType","hasAttribute","addEventListener","passive","renderLoop","AlpineComponentLoader","replaceChildren","removeEventListener","components","querySelectorAll","children","usedBoxCount","forEach","el","rect","getBoundingClientRect","nodes","shadowRoot","length","minX","Infinity","minY","maxX","maxY","found","cRect","child","Math","min","max","right","bottom","window","innerHeight","innerWidth","box","transform","i","textContent","getAttribute","_loading","JSON","stringify","$props","tRect","winW","winH","requestAnimationFrame","console","error"],"mappings":"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","file":"ACLDebugger.min.js","sourcesContent":["/**\n * @license ACLDebugger\n *\n * Copyright (c) LTDev LLC\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// CSS for debugger\nconst debuggerCss = {\n    tooltip: {\n        position: 'fixed',\n        zIndex: 10000,\n        background: '#1f2937',\n        color: '#f3f4f6',\n        padding: '8px 12px',\n        borderRadius: '6px',\n        fontSize: '11px',\n        fontFamily: 'monospace',\n        pointerEvents: 'none',\n        border: '1px solid #374151',\n        boxShadow: '0 4px 6px -1px rgba(0,0,0,0.1)',\n        maxWidth: '300px',\n        whiteSpace: 'pre-wrap',\n        display: 'none',\n    },\n    overlay: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        pointerEvents: 'none',\n        zIndex: 9998,\n        overflow: 'hidden'\n    },\n    overlayBoxes: {\n        position: 'absolute',\n        border: '4px solid #22c55e',\n        boxSizing: 'border-box',\n    }\n};\n\n// Helper to convert JS style objects to CSS strings\nconst toCssString = (styleObj) => {\n    return Object.entries(styleObj)\n        .map(([k, v]) => `${k.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`)}:${v}`)\n        .join(';');\n};\n\n// Debugger class to inject into the AlpineComponentLoader class\nexport default class ACLDebugger {\n    static inject(loaderClass) {\n        if (!loaderClass) {\n            console.error('[ACLDebugger] No ComponentLoader class provided to inject().');\n            return;\n        }\n\n        // Overwrite the stub method with the real implementation\n        loaderClass.toggleDebug = function () {\n            const active = (this.globalConfig.debug = !this.globalConfig.debug);\n            document.body.classList.toggle('acl-debug-active', active);\n\n            // Create the tooltip element if it doesn't exist\n            let tooltip = document.getElementById('acl-debug-tooltip');\n            if (!tooltip) {\n                tooltip = document.createElement('div');\n                tooltip.id = 'acl-debug-tooltip';\n                tooltip.style.cssText = toCssString(debuggerCss.tooltip);\n\n                // Title\n                const titleNode = document.createElement('strong');\n                titleNode.style.color = '#4ade80';\n\n                // Title separator\n                const hr = document.createElement('div');\n                hr.style.margin = '4px 0';\n                hr.style.borderBottom = '1px solid #374151';\n\n                // Status info\n                const statusNode = document.createElement('div');\n\n                // Prop info\n                const propsNode = document.createElement('pre');\n                propsNode.style.cssText = 'margin: 4px 0 0 0; opacity: 0.8;';\n\n                // Append once\n                tooltip.append(titleNode, hr, statusNode, propsNode);\n\n                // Save references for fast updates\n                tooltip._nodes = { title: titleNode, status: statusNode, props: propsNode };\n\n                // Append to body\n                document.body.appendChild(tooltip);\n            }\n\n            // Create the overlay container if it doesn't exist\n            let overlayContainer = document.getElementById('acl-debug-overlays');\n            if (!overlayContainer) {\n                overlayContainer = document.createElement('div');\n                overlayContainer.id = 'acl-debug-overlays';\n                overlayContainer.style.cssText = toCssString(debuggerCss.overlay);\n                document.body.appendChild(overlayContainer);\n            }\n\n            // State management, tracking hovered component + mouse position\n            let mouseX = 0,\n                mouseY = 0,\n                hoveredElement = null;\n\n            // Lightweight mouse listener for finding hovered component + mouse position\n            const onMouseMove = (e) => {\n                mouseX = e.clientX;\n                mouseY = e.clientY;\n\n                // Find hovered component (handling Shadow DOM)\n                hoveredElement = (e.composedPath() || []).find(node => node.nodeType === 1 && node.hasAttribute('data-acl-component'));\n            };\n\n            // If active, start debugging!\n            if (active) {\n                document.addEventListener('mousemove', onMouseMove, { passive: true });\n\n                // Render loop, with throttling, handles overlay + tooltip\n                const renderLoop = () => {\n                    if (!AlpineComponentLoader.globalConfig.debug) {\n                        overlayContainer.replaceChildren(); // Cleanup\n                        tooltip.style.display = 'none';\n                        document.removeEventListener('mousemove', onMouseMove);\n                        return;\n                    }\n\n                    // Overlay logic (DOM Pooling) for component positions\n                    const components = document.querySelectorAll('[data-acl-component]'),\n                        children = overlayContainer.children;\n                    let usedBoxCount = 0;\n\n                    // Measure all components recursively to find visible areas\n                    components.forEach((el) => {\n                        let rect = el.getBoundingClientRect();\n\n                        // Attempt to find visible area of children for collapsed elements\n                        if (rect.width === 0 && rect.height === 0) {\n                            const nodes = el.shadowRoot ? el.shadowRoot.children : el.children;\n                            if (nodes.length > 0) {\n                                let minX = Infinity,\n                                    minY = Infinity,\n                                    maxX = -Infinity,\n                                    maxY = -Infinity,\n                                    found = false;\n\n                                // Measure children recursively until we find a valid visible area\n                                for (const child of nodes) {\n                                    const cRect = child.getBoundingClientRect();\n                                    if (cRect.width > 0 || cRect.height > 0) {\n                                        found = true;\n                                        minX = Math.min(minX, cRect.left);\n                                        minY = Math.min(minY, cRect.top);\n                                        maxX = Math.max(maxX, cRect.right);\n                                        maxY = Math.max(maxY, cRect.bottom);\n                                    }\n                                }\n\n                                // Found a valid visible area, use it\n                                if (found)\n                                    rect = {\n                                        left: minX,\n                                        top: minY,\n                                        width: maxX - minX,\n                                        height: maxY - minY\n                                    };\n                            }\n                        }\n\n                        // Only draw if we have a valid visible area\n                        if (rect.width > 0 && rect.height > 0 &&\n                            rect.top < window.innerHeight &&\n                            rect.left < window.innerWidth &&\n                            (rect.top + rect.height) > 0 &&\n                            (rect.left + rect.width) > 0\n                        ) {\n                            // Reuse existing box or create new one\n                            let box = children[usedBoxCount];\n                            if (!box) {\n                                box = document.createElement('div');\n                                box.style.cssText = toCssString(debuggerCss.overlayBoxes);\n                                overlayContainer.appendChild(box);\n                            }\n\n                            // Fast style update\n                            box.style.transform = `translate(${rect.left}px, ${rect.top}px)`;\n                            box.style.width = `${rect.width}px`;\n                            box.style.height = `${rect.height}px`;\n                            box.style.display = 'block'; // Ensure it's visible\n\n                            // Count the used boxes\n                            usedBoxCount++;\n                        }\n                    });\n\n                    // Hide unused boxes in the pool\n                    for (let i = usedBoxCount; i < children.length; i++)\n                        children[i].style.display = 'none';\n\n                    // Tooltip logic, apply position + content\n                    if (hoveredElement) {\n                        tooltip.style.display = 'block';\n\n                        // Content Update\n                        tooltip._nodes.title.textContent = `<${hoveredElement.getAttribute('data-acl-component')}>`;\n                        tooltip._nodes.status.textContent = hoveredElement._loading ? 'Loading...' : 'Ready';\n                        tooltip._nodes.status.style.color = hoveredElement._loading ? '#fbbf24' : '#4ade80';\n\n                        // Display all props\n                        tooltip._nodes.props.textContent = JSON.stringify(hoveredElement.$props, null, 2);\n\n                        // Base position information\n                        const offset = 15,\n                            tRect = tooltip.getBoundingClientRect(),\n                            winW = window.innerWidth,\n                            winH = window.innerHeight;\n\n                        // Initial positioning\n                        let left = mouseX + offset,\n                            top = mouseY + offset;\n\n                        // Keep tooltip on screen within offset\n                        if (left + tRect.width > winW)\n                            left = mouseX - tRect.width - offset;\n                        if (top + tRect.height > winH)\n                            top = mouseY - tRect.height - offset;\n                        if (left < 0)\n                            left = offset;\n                        if (top < 0)\n                            top = offset;\n\n                        // Update position\n                        tooltip.style.left = `${left}px`;\n                        tooltip.style.top = `${top}px`;\n                    } else {\n                        tooltip.style.display = 'none';\n                    }\n                    requestAnimationFrame(renderLoop);\n                };\n                requestAnimationFrame(renderLoop);\n            }\n        }\n    }\n}"]}
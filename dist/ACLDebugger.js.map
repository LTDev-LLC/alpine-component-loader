{"version":3,"sources":["../src/debugger.js"],"names":["debuggerCss","tooltip","position","zIndex","background","color","padding","borderRadius","fontSize","fontFamily","pointerEvents","border","boxShadow","maxWidth","whiteSpace","display","overlay","top","left","width","height","overflow","overlayBoxes","boxSizing","overlayBoxesColors","default","update","toCssString","styleObj","Object","entries","map","k","v","replace","m","toLowerCase","join","ACLDebugger","inject","loaderClass","console","error","toggleDebug","active","globalConfig","debug","document","body","classList","toggle","getElementById","createElement","id","style","cssText","titleNode","hr","margin","borderBottom","statusNode","perfNode","marginTop","propsNode","append","_nodes","title","status","perf","props","appendChild","overlayContainer","mouseX","mouseY","hoveredElement","onMouseMove","e","clientX","clientY","composedPath","find","node","nodeType","hasAttribute","addEventListener","passive","renderLoop","AlpineComponentLoader","replaceChildren","removeEventListener","components","querySelectorAll","children","usedBoxCount","forEach","el","rect","getBoundingClientRect","nodes","shadowRoot","length","minX","Infinity","minY","maxX","maxY","found","child","cRect","Math","min","max","right","bottom","window","innerHeight","innerWidth","box","transform","borderColor","$props","$lastUpdated","Date","now","i","textContent","getAttribute","_loading","_perf","duration","time","toFixed","JSON","stringify","offset","tRect","winW","winH","requestAnimationFrame"],"mappings":"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","file":"ACLDebugger.js","sourcesContent":["/**\n * @license ACLDebugger\n *\n * Copyright (c) LTDev LLC\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// CSS for debugger\nconst debuggerCss = {\n    tooltip: {\n        position: 'fixed',\n        zIndex: 10000,\n        background: '#1f2937',\n        color: '#f3f4f6',\n        padding: '8px 12px',\n        borderRadius: '6px',\n        fontSize: '11px',\n        fontFamily: 'monospace',\n        pointerEvents: 'none',\n        border: '1px solid #374151',\n        boxShadow: '0 4px 6px -1px rgba(0,0,0,0.1)',\n        maxWidth: '300px',\n        whiteSpace: 'pre-wrap',\n        display: 'none',\n    },\n    overlay: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        pointerEvents: 'none',\n        zIndex: 9998,\n        overflow: 'hidden'\n    },\n    overlayBoxes: {\n        position: 'absolute',\n        border: '4px solid',\n        boxSizing: 'border-box',\n    },\n    overlayBoxesColors: {\n        default: '#22c55e',\n        update: '#fbbf24',\n    },\n};\n\n// Helper to convert JS style objects to CSS strings\nconst toCssString = (styleObj) => {\n    return Object.entries(styleObj)\n        .map(([k, v]) => `${k.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`)}:${v}`)\n        .join(';');\n};\n\n// Debugger class to inject into the AlpineComponentLoader class\nexport default class ACLDebugger {\n    static inject(loaderClass) {\n        if (!loaderClass) {\n            console.error('[ACLDebugger] No ComponentLoader class provided to inject().');\n            return;\n        }\n\n        // Overwrite the stub method with the real implementation\n        loaderClass.toggleDebug = function () {\n            const active = (this.globalConfig.debug = !this.globalConfig.debug);\n            document.body.classList.toggle('acl-debug-active', active);\n\n            // Create the tooltip element if it doesn't exist\n            let tooltip = document.getElementById('acl-debug-tooltip');\n            if (!tooltip) {\n                tooltip = document.createElement('div');\n                tooltip.id = 'acl-debug-tooltip';\n                tooltip.style.cssText = toCssString(debuggerCss.tooltip);\n\n                // Title\n                const titleNode = document.createElement('strong');\n                titleNode.style.color = '#4ade80';\n\n                // Title separator\n                const hr = document.createElement('div');\n                hr.style.margin = '4px 0';\n                hr.style.borderBottom = '1px solid #374151';\n\n                // Status info\n                const statusNode = document.createElement('div');\n\n                // Performance info\n                const perfNode = document.createElement('div');\n                perfNode.style.marginTop = '2px';\n                perfNode.style.fontSize = '0.9em';\n\n                // Prop info\n                const propsNode = document.createElement('pre');\n                propsNode.style.cssText = 'margin: 4px 0 0 0; opacity: 0.8;';\n\n                // Append once\n                tooltip.append(titleNode, hr, statusNode, perfNode, propsNode);\n\n                // Save references for fast updates\n                tooltip._nodes = { title: titleNode, status: statusNode, perf: perfNode, props: propsNode };\n\n                // Append to body\n                document.body.appendChild(tooltip);\n            }\n\n            // Create the overlay container if it doesn't exist\n            let overlayContainer = document.getElementById('acl-debug-overlays');\n            if (!overlayContainer) {\n                overlayContainer = document.createElement('div');\n                overlayContainer.id = 'acl-debug-overlays';\n                overlayContainer.style.cssText = toCssString(debuggerCss.overlay);\n                document.body.appendChild(overlayContainer);\n            }\n\n            // State management, tracking hovered component + mouse position\n            let mouseX = 0,\n                mouseY = 0,\n                hoveredElement = null;\n\n            // Lightweight mouse listener for finding hovered component + mouse position\n            const onMouseMove = (e) => {\n                mouseX = e.clientX;\n                mouseY = e.clientY;\n\n                // Find hovered component (handling Shadow DOM)\n                hoveredElement = (e.composedPath() || []).find(node => node.nodeType === 1 && node.hasAttribute('data-acl-component'));\n            };\n\n            // If active, start debugging!\n            if (active) {\n                document.addEventListener('mousemove', onMouseMove, { passive: true });\n\n                // Render loop, with throttling, handles overlay + tooltip\n                const renderLoop = () => {\n                    if (!AlpineComponentLoader.globalConfig.debug) {\n                        overlayContainer.replaceChildren(); // Cleanup\n                        tooltip.style.display = 'none';\n                        document.removeEventListener('mousemove', onMouseMove);\n                        return;\n                    }\n\n                    // Overlay logic (DOM Pooling) for component positions\n                    const components = document.querySelectorAll('[data-acl-component]'),\n                        children = overlayContainer.children;\n                    let usedBoxCount = 0;\n\n                    // Measure all components recursively to find visible areas\n                    components.forEach((el) => {\n                        let rect = el.getBoundingClientRect();\n\n                        // Attempt to find visible area of children for collapsed elements\n                        if (rect.width === 0 && rect.height === 0) {\n                            const nodes = el.shadowRoot ? el.shadowRoot.children : el.children;\n                            if (nodes.length > 0) {\n                                let minX = Infinity,\n                                    minY = Infinity,\n                                    maxX = -Infinity,\n                                    maxY = -Infinity,\n                                    found = false;\n\n                                // Measure children recursively until we find a valid visible area\n                                for (const child of nodes) {\n                                    const cRect = child.getBoundingClientRect();\n                                    if (cRect.width > 0 || cRect.height > 0) {\n                                        found = true;\n                                        minX = Math.min(minX, cRect.left);\n                                        minY = Math.min(minY, cRect.top);\n                                        maxX = Math.max(maxX, cRect.right);\n                                        maxY = Math.max(maxY, cRect.bottom);\n                                    }\n                                }\n\n                                // Found a valid visible area, use it\n                                if (found)\n                                    rect = {\n                                        left: minX,\n                                        top: minY,\n                                        width: maxX - minX,\n                                        height: maxY - minY\n                                    };\n                            }\n                        }\n\n                        // Only draw if we have a valid visible area\n                        if (rect.width > 0 && rect.height > 0 &&\n                            rect.top < window.innerHeight &&\n                            rect.left < window.innerWidth &&\n                            (rect.top + rect.height) > 0 &&\n                            (rect.left + rect.width) > 0\n                        ) {\n                            // Reuse existing box or create new one\n                            let box = children[usedBoxCount];\n                            if (!box) {\n                                box = document.createElement('div');\n                                box.style.cssText = toCssString(debuggerCss.overlayBoxes);\n                                overlayContainer.appendChild(box);\n                            }\n\n                            // Fast style update\n                            box.style.transform = `translate(${rect.left}px, ${rect.top}px)`;\n                            box.style.width = `${rect.width}px`;\n                            box.style.height = `${rect.height}px`;\n                            box.style.display = 'block'; // Ensure it's visible\n\n                            // Flash border color when updated\n                            box.style.borderColor = debuggerCss.overlayBoxesColors[\n                                (el.$props?.$lastUpdated && ((Date.now() - el.$props.$lastUpdated) < 1000))\n                                    ? 'update'\n                                    : 'default'\n                            ];\n\n                            // Count the used boxes\n                            usedBoxCount++;\n                        }\n                    });\n\n                    // Hide unused boxes in the pool\n                    for (let i = usedBoxCount; i < children.length; i++)\n                        children[i].style.display = 'none';\n\n                    // Tooltip logic, apply position + content\n                    if (hoveredElement) {\n                        tooltip.style.display = 'block';\n\n                        // Content Update\n                        tooltip._nodes.title.textContent = `<${hoveredElement.getAttribute('data-acl-component')}>`;\n                        tooltip._nodes.status.textContent = hoveredElement._loading ? 'Loading...' : 'Ready';\n                        tooltip._nodes.status.style.color = hoveredElement._loading ? '#fbbf24' : '#4ade80';\n\n                        // Display perf metrics\n                        if (hoveredElement._perf && hoveredElement._perf.duration) {\n                            const time = hoveredElement._perf.duration.toFixed(1);\n                            tooltip._nodes.perf.textContent = `Load: ${time}ms`;\n                            tooltip._nodes.perf.style.color = time > 100 ? '#f87171' : '#94a3b8';\n                            tooltip._nodes.perf.style.display = 'block';\n                        } else {\n                            tooltip._nodes.perf.style.display = 'none';\n                        }\n\n                        // Display all props\n                        tooltip._nodes.props.textContent = JSON.stringify(hoveredElement.$props, null, 2);\n\n                        // Base position information\n                        const offset = 15,\n                            tRect = tooltip.getBoundingClientRect(),\n                            winW = window.innerWidth,\n                            winH = window.innerHeight;\n\n                        // Initial positioning\n                        let left = mouseX + offset,\n                            top = mouseY + offset;\n\n                        // Keep tooltip on screen within offset\n                        if (left + tRect.width > winW)\n                            left = mouseX - tRect.width - offset;\n                        if (top + tRect.height > winH)\n                            top = mouseY - tRect.height - offset;\n                        if (left < 0)\n                            left = offset;\n                        if (top < 0)\n                            top = offset;\n\n                        // Update position\n                        tooltip.style.left = `${left}px`;\n                        tooltip.style.top = `${top}px`;\n                    } else {\n                        tooltip.style.display = 'none';\n                    }\n                    requestAnimationFrame(renderLoop);\n                };\n                requestAnimationFrame(renderLoop);\n            }\n        }\n    }\n}"]}